# 1931번 회의실 배정

<aside>

## 문제

한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.

</aside>

<aside>

## 입력

첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 231-1보다 작거나 같은 자연수 또는 0이다.

</aside>

<aside>

## 출력

첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다.

</aside>

이 문제는 그리디 알고리즘을 활용한 문제이다.

[그리디 알고리즘](https://www.notion.so/26fe73cfe03f80ef83f1ef4d6b2fef6d?pvs=21)

문제의 조건은 다음과 같다.

<aside>

1. 회의실의 사용 시간이 겹치지 않기
2. 한 회의가 끝남과 동시에 다른 회의가 시작할 수 있음
3. 회의의 시작 시간과 끝나는 시간이 같을 수 있다.
</aside>

문제의 핵심은 **시작 시간이 빨라도, 회의의 시간이 길다면 회의의 최대 갯수를 맞출 수 없다는 것**이다.

따라서, `vector 배열`에 회의의 시작 시간과 마치는 시간을 각각 넣고, 오름차순으로 정렬한다.

이때, **정렬의 기준은 종료 시간**이 되어야 하기 때문에 **`v.first`에는 종료 시간**이, **`v.second`에는 시작 시간**이 들어가야 한다.

```cpp
	int time = v[0].first;
	int cnt = 1;
```

그리고 변수 `time`에는 가장 빠른 종료 시간을 저장한다.

변수 `cnt`는 **첫 번째 회의를 마쳤다고 가정**하기 때문에, **1을 저장**한다.

```cpp
for (int i = 1; i < n; i++) {
	if (time <= v[i].second) {
		cnt++;
		time = v[i].first;
	}
}
```

**i번째 회의의 시작 시간이 첫 번째 회의의 종료 시간보다 늦다면**, **`time`에 i번째 회의의 종료 시간을 저장**하고, **전체 회의를 탐색할 때까지 반복**한다.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int n;
vector <pair<int, int>> v;

int main() {
	cin >> n;
	for (int i = 0; i < n; i++) {
		int b, e;
		cin >> b >> e;
		v.push_back({ e, b });
		// 종료 시점을 먼저 넣는다.
	}
	sort(v.begin(), v.end());
	// 종료 시점을 기준으로 오름차순 정렬

	int time = v[0].first;	// 첫 번째 회의의 종료 시간
	int cnt = 1;	// 첫 번째 회의를 마쳤다고 가정하기 때문에 1로 저장
	for (int i = 1; i < n; i++) {
	// 첫 번째 회의를 이미 했기 때문에 i=1부터 반복 시작
		if (time <= v[i].second) {
		// 첫 번째 회의의 종료 시간 <= i번째 회의의 시작 시간
			cnt++;
			time = v[i].first;
			// time = i번째 회의의 종료 시간
		}
	}
	cout << cnt << endl;
}
```
