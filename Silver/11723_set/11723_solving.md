# 11723번 집합

<aside>

## 문제

비어있는 공집합 S가 주어졌을 때, 아래 연산을 수행하는 프로그램을 작성하시오.

- `add x`: S에 x를 추가한다. (1 ≤ x ≤ 20) S에 x가 이미 있는 경우에는 연산을 무시한다.
- `remove x`: S에서 x를 제거한다. (1 ≤ x ≤ 20) S에 x가 없는 경우에는 연산을 무시한다.
- `check x`: S에 x가 있으면 1을, 없으면 0을 출력한다. (1 ≤ x ≤ 20)
- `toggle x`: S에 x가 있으면 x를 제거하고, 없으면 x를 추가한다. (1 ≤ x ≤ 20)
- `all`: S를 {1, 2, ..., 20} 으로 바꾼다.
- `empty`: S를 공집합으로 바꾼다.
</aside>

<aside>

## 입력

첫째 줄에 수행해야 하는 연산의 수 M (1 ≤ M ≤ 3,000,000)이 주어진다.

둘째 줄부터 M개의 줄에 수행해야 하는 연산이 한 줄에 하나씩 주어진다.

</aside>

<aside>

## 출력

`check` 연산이 주어질때마다, 결과를 출력한다.

</aside>

이 문제는 처음엔 아래와 같이 `set`함수들을 활용하여 풀어보려고 했다.

```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
	int m;
	set <int> a;
	cin >> m;

	while (m--) {
		string s;
		int num;
		cin >> s;

		if (s == "add") {
			cin >> num;
			a.insert(num);
		}
		else if (s == "remove") {
			cin >> num;
			a.erase(num);
		}
		else if (s == "check") {
			cin >> num;
			if (a.count(num)) {
				cout << 1 << endl;
			}
			else {
				cout << 0 << endl;
			}
		}
		else if (s == "toggle") {
			cin >> num;
			if (a.count(num)) {
				a.erase(num);
			}
			else {
				a.insert(num);
			}
		}
		else if (s == "all") {
			for (int i = 1; i <= 20; i++) {
				a.insert(i);
			}
		}
		else if (s == "empty") {
			a.clear();
		}
	}
}
```

그러나 이렇게 문제를 풀게 되면 숫자가 커질수록 연산의 횟수도 기하급수적으로 늘어나서 결국에는 시간 초과를 발생시킨다. 이를 해결하기 위해서는 **비트마스킹**을 활용해야한다.

<aside>

### 비트마스킹이란?

- 특정 숫자들을 비트 단위로 표현하고, 비트 연산자(OR, XOR, AND 등)를 활용하여 집합의 원소를 다루듯이 데이터를 처리하는 방법
- 이진수(비트)의 연산을 이용해 데이터를 효율적으로 관리하는 프로그래밍 기법
</aside>

<aside>

### 장점

**간결한 코드** : 여러 개의 조건문이나 반복문을 사용하지 않고, 한 줄의 비트 연산으로 복잡한 논리를 표현할 수 있다.

**메모리 효율성** : 적은 메모리로 많은 상태를 표시할 수 있다.

**매우 빠른 속도** : CPU가 가장 빠르게 처리할 수 있는 기본 연산이다.

</aside>

<aside>

### 단점

**제한된 범위** : 비트마스킹은 주로 정수형 변수가 표현할 수 있는 비트 수만큼 데이터를 다룰 때 효과적이기 때문에 그보다 큰 범위를 다룬다면 비트마스킹만으로는 해결하기 어렵다.

**디버깅의 까다로움** : 비트 연산 오류가 발생했을 때, 변수의 값을 이진수로 변환해서 확인해야 하므로 디버깅이 까다롭다.

**가독성 저하** : 직관적인 코드는 아니기 때문에 익숙하지 않은 사람은 이해하기 어렵다.

</aside>

<aside>

### 기본적인 비트 연산자

| **연산자** | **기호** | **의미** | **활용 예시** |
| --- | --- | --- | --- |
| AND |     & | 두 비트가 모두 1일 때만 1을 반환 | 특정 비트가 켜져 있는지 확인 |
| OR |      | | 두 비트 중 하나라도 1이면 1을 반환 | 특정 비트 켜기 |
| XOR |     ^ | 두 비트가 다를 때만 1을 반환 | 특정 비트 뒤집기(toggle) |
| NOT |     ~ | 비트를 반전시킴(0은 1로, 1은 0으로) | 비트 끄기 연산에 사용 |
| SHIFT |    << | 비트를 왼쪽으로 이동 | 특정 위치에 1을 만들기 |
| SHIFT |    >> | 비트를 오른쪽으로 이동 | 특정 비트 추출 |
</aside>

<aside>

### 사용 예시

- 집합에 3을 추가할 때 → **3번째 비트를 1로 바꾸는 것과 같음**
    
    <img width="344" height="141" alt="Image" src="https://github.com/user-attachments/assets/d74ac74c-0fb1-4481-a924-1552cddaf0be" />
    

- 집합에서 3을 제거할 때 → **3번째 비트를 0으로 바꾸는 것과 같음**

<img width="253" height="140" alt="Image" src="https://github.com/user-attachments/assets/4d21ab46-091f-467e-be55-3bfd3b825533" />

</aside>

위와 같이 비트마스킹의 특성상 1부터 20까지의 작은 범위 내에서는 매우 빠른 속도로 연산을 수행할 수 있어서 set 함수를 사용하는 것보다 훨씬 적은 시간으로 문제를 해결하는 것이 가능하다.

```cpp
#include <iostream>
using namespace std;

int main() {
	ios_base::sync_with_stdio(false); // C++ 표준 스트림 동기화 해제
	cin.tie(NULL); // cin과 cout의 연결 해제

	int m;
	int S = 0;
	cin >> m;

	while (m--) {
		string cmd;
		int x;
		cin >> cmd;

		if (cmd == "add") {	// 명령어가 add이면
			cin >> x;
			S |= (1 << (x - 1));	// S의 x번째 비트를 1로 바꾼다.
		}
		else if (cmd == "remove") { // 명령어가 remove이면
			cin >> x;
			S &= ~(1 << (x - 1));	// S의 x번째 비트를 0으로 바꾼다.
		}
		else if (cmd == "check") {	// 명령어가 check일 때,
			cin >> x;
			if (S & (1 << (x - 1))) {	// S의 x번째 비트가 1이면
				cout << 1 << "\n";	// 1을 출력한다.
			}
			else {	// S의 x번째 비트가 0이면
				cout << 0 << "\n";	// 0을 출력한다.
			}
		}
		else if (cmd == "toggle") {	// 명령어가 toggle이면
			cin >> x;
			S ^= (1 << (x - 1));	// x번째 비트가 1이면 0으로, 0이면 1로 변환
		}
		else if (cmd == "all") {	// 명령어가 all이면
			S = (1 << 20) - 1;	// 1~20번째까지의 비트를 전부 1로 바꾼다.
		}
		else if (cmd == "empty") {	// 명령어가 empty이면
			S = 0;	// 1~20번째까지의 비트를 전부 0으로 바꾼다.
		}
	}
}
```

위와 같이 비트마스킹을 활용하여 코드를 만들면 문제를 해결할 수 있다.

개인적으로 all 명령어 코드를 만드는 것이 어려웠는데, 해당 코드의 원리는 아래와 같다.

<aside>

## all 명령어 코드 원리

### **1. `(1 << 20)` 연산**

- `<<` : **왼쪽 시프트 연산자**
- 이 연산은 **2진수의 비트들을 왼쪽으로 이동**시키는 역할을 한다.
    
    `1 << 20`은 **1**이라는 2진수 값을 왼쪽으로 **20칸** 이동시키는 것이다.
    
- 원래 값: 10진수 **1**은 2진수로 `00000001` (8비트 기준)
- 20칸 이동: 이 비트가 왼쪽으로 20칸 이동하면, **21번째 비트**에 1이 오게 된다.
`100000000000000000000` (21번째 비트가 1)

### **2. `- 1` 연산**

- 어떤 2진수에서 1을 빼면, 그 수의 가장 오른쪽 1이 0으로 바뀌고, 그 오른쪽의 모든 0이 1로 바뀐다.
    - 예시: `1000`(8)에서 1을 빼면 `0111`(7)이 된다.
    - 예시: `100` (4)에서 1을 빼면 `011` (3)이 된다.
- 따라서 `(1 << 20)` 의 값에서 1을 빼면, 21번째 비트가 0으로 바뀌고, 1~20번째 비트는 모두 1이 된다.
    - `1 << 20`: `100000000000000000000` (21번째 비트가 1)
    - `-1` : `011111111111111111111` (1~20번째 비트가 1)
</aside>
