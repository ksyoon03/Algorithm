# 1463번 1로 만들기

<aside>

## 문제

정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

X가 3으로 나누어 떨어지면, 3으로 나눈다.

X가 2로 나누어 떨어지면, 2로 나눈다.

1을 뺀다.

정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

</aside>

<aside>

## 입력

첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.

</aside>

<aside>

## 출력

첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.

</aside>

해당 문제는 동적 계획법(다이나믹 프로그래밍)을 활용하는 문제이다.

우선 이 문제를 풀기 위해서는 아래 코드의 동작 방식을 이해해야 한다.

```cpp
dp[1] = 0;

for (int i = 2; i <= n; i++) {
	dp[i] = dp[i - 1] + 1;
	
	if (i % 2 == 0) {
		dp[i] = min(dp[i], dp[i / 2] + 1);
	}

	if (i % 3 == 0) {
		dp[i] = min(dp[i], dp[i / 3] + 1);
	}
}
```

<aside>

## 동작 예시)

- `n = 10`
- `1`일 때는 나누거나 뺄 수 없기 때문에 `dp[1] = 0`
    
    ```cpp
    dp[1] = 0;
    ```
    
1. `dp[1]`에 `0`을 저장했기 때문에 2부터 `n`까지 반복 시작
    
    ```cpp
    for (int i = 2; i <= n; i++){
    ...
    }
    ```
    

1. `i`는 2일 때,
    - `dp[2] = dp[2 - 1] + 1` → `dp[2] = dp[1] + 1` → `dp[2] = 0 + 1` → `dp[2] = 1`
    - `if (2 % 2 == 0)`
        - 2는 짝수이므로 if문 안으로 들어간다.
    - `dp[2] = min(dp[2], dp[2 / 2] + 1)`
        - `dp[2]`에 저장된 현재 값(`1`)과 `dp[1] + 1` (`0 + 1 = 1`)을 비교한다.
        - `min(1, 1)`은 `1`이므로 `dp[2] = 1`

1. `i`는 3일 때,
    - `dp[3] = dp[3 - 1] + 1` → `dp[3] = dp[2] + 1` → `dp[3] = 1 + 1` → `dp[3] = 2`
    - `if (i % 3 == 0)`
        - 3은 홀수이므로 3의 배수미으로 if문 안으로 들어간다.
    - `dp[3] = min(dp[3], dp[3 / 3] + 1)`
        - `dp[3]`에 저장된 현재 값(`2`)과 `dp[1] + 1` (`0 + 1 = 1`)을 비교한다.
        - `min(2, 1)`은 `1`이므로 `dp[3] = 1`

1. `i`는 10일 때,
    - `dp[10] = dp[10 - 1] + 1` → `dp[10] = dp[9] + 1` → `dp[10] = 2 + 1` → `dp[10] = 3`
    - `if(10 % 2 == 0)`
        - 10은 짝수이므로 if문 안에 들어간다.
    - `dp[10] = min(dp[10], dp[10 / 2] + 1)`
        - `dp[10]`에 저장된 현재 값(`3`)과 `dp[5] + 1` (`3 + 1 = 4`)을 비교한다.
        - `min(3, 4)`는 `3`이므로 `dp[10] = 3`
</aside>

위와 같은 동작 방식으로 코드를 작성하면 답을 구할 수 있다.

```cpp
#include <iostream>
using namespace std;

int dp[1000001];

int main() {
	int n;
	cin >> n;

	dp[1] = 0;	// 1은 나누거나 뺄 수 없기 때문에 0

	for (int i = 2; i <= n; i++) {	// 2부터 반복 시작
		dp[i] = dp[i - 1] + 1;	// i번째 = i-1번째에 저장된 값 + 1
		
		if (i % 2 == 0) {		// i가 2로 나누어 떨어지면
			dp[i] = min(dp[i], dp[i / 2] + 1);
			// i번째 = 원래 i번째 값과 (i / 2번째에 저장된 값 + 1) 중 더 작은 값
		}

		if (i % 3 == 0) {		// i가 3으로 나누어 떨어지면
			dp[i] = min(dp[i], dp[i / 3] + 1);
			// i번째 = 원래 i번째 값과 (i / 3번째에 저장된 값 + 1) 중 더 작은 값
		}
	}

	cout << dp[n] << endl;
	// n번째에 저장된 값 출력
}
```