# 9095번 1, 2, 3 더하기

<aside>
💡

## 문제

정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 7가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다.

- 1+1+1+1
- 1+1+2
- 1+2+1
- 2+1+1
- 2+2
- 1+3
- 3+1

정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.

</aside>

<aside>
💡

## 입력

첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 11보다 작다.

</aside>

<aside>
💡

## 출력

각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 출력한다.

</aside>

문제의 `n`을 만드는 방법을 찾는 방법의 수는 **`n`보다 작은 수를 만드는 방법의 수**를 활용해 만들 수 있다.

즉, 이 문제는 **점화식**을 찾는 것이 핵심인 문제라고 할 수 있다.

<aside>

## 점화식 찾기

- 마지막에 `1`을 더하는 경우의 수: `n - 1`
- 마지막에 `2`를 더하는 경우의 수: `n - 2`
- 마지막에 `3`를 더하는 경우의 수: `n - 3`

따라서 `n`을 만드는 방법의 수 `f(n)`은 다음과 같은 **점화식**으로 나타낼 수 있다.

- `f(n) = f(n - 3) + f(n - 2) + f(n - 1)`
</aside>

찾아낸 점화식을 활용하여 만든 코드는 다음과 같다.

```cpp
#include <iostream>
using namespace std;

int t, n;
int dp[12];

int main() {
	cin >> t;

	dp[1] = 1;	// 1이 되는 경우의 수는 1 밖에 없음
	dp[2] = 2;
	// 2가 되는 경우의 수: 2가지
	// 1 + 1
	// 2
	dp[3] = 4;
	// 3이 되는 경우의 수: 4가지
	// 1 + 1 + 1
	// 1 + 2
	// 2 + 1
	// 3

	while (t-- > 0) {	
		for (int i = 4; i <= 11; i++) {
			dp[i] = 0;	// 반복 후 배열 초기화
		}
		cin >> n;
		for (int i = 4; i <= n; i++) {
		// dp[1 ~ 3]까지는 이미 있기 때문에 4부터 n까지 반복 시작
			dp[i] = dp[i - 3] + dp[i - 2] + dp[i - 1];
			// 점화식
		}

		cout << dp[n] << endl;
	}
}
```